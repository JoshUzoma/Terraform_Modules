name: Terraform CI/CD with tfsec and SonarQube

on:
  push:
    branches: [main]
    paths:
      - 'user*/**'  # Triggers if any user folder changes
  workflow_dispatch:  # Manual trigger
  
env:
      AWS_REGION: us-east-2
      KICS_S3_BUCKET: kics-log-bucket
      SQ_S3_BUCKET: sq-log-bucket
      PROJECT_NAME: htown-sp-sonarqube
jobs:
  detect-folders:
    runs-on: ubuntu-latest
    outputs:
      folders: ${{ steps.set-folders.outputs.folders }}
    steps:
      - uses: actions/checkout@v4
        with:
           fetch-depth: 0
           
      - id: set-folders
        run: |
          echo "Detecting user folders with changes..."
          folders=$(git diff --name-only ${{ github.event.before }} ${{ github.sha }} | grep '^user' | cut -d/ -f1 | sort -u | uniq | jq -R -s -c 'split("\n") | map(select(length > 0))')
          echo "folders=$folders" >> $GITHUB_OUTPUT
          
  run-ci:
    name: Run Terraform CI/CD
    needs: detect-folders
    runs-on: ubuntu-latest
    if: needs.detect-folders.outputs.folders != '[]'
    strategy:
      matrix:
        folder: ${{ fromJson(needs.detect-folders.outputs.folders) }}
    outputs:
      folder: ${{ matrix.folder }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.ACCESS_KEY }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}  # Make this env variable
          
      # Static Code Scanning (Before Apply)
      
      - name: Run KICS Scan
        uses: checkmarx/kics-github-action@v2.1.11
        with:
          path: '${{ matrix.folder }}'
          output_path: ${{ matrix.folder }}/kics-output
        continue-on-error: true  # Let pipeline continue even if KICS finds issues
        
      - name: Upload KICS Results
        uses: actions/upload-artifact@v4
        with:
          name: kics-results-${{ matrix.folder }}
          path: ${{ matrix.folder }}/kics-output
          
      - name: Upload KICS Results to S3
        run: |
          if ls ${{ matrix.folder }}/kics-output/* 1> /dev/null 2>&1; then
            timestamp=$(date +%Y%m%d-%H%M%S)
            for file in ${{ matrix.folder }}/kics-output/*; do
              filename=$(basename "$file")
              echo "Uploading $filename for ${{ matrix.folder }} to S3..."
              aws s3 cp "$file" \
                "s3://$KICS_S3_BUCKET/kics-results/${{ matrix.folder }}/$timestamp/$filename"
            done
          else
            echo "No KICS results found to upload."
          fi
          
      # Uncomment this block to enforce security gates before apply
      # - name: Fail on critical/high KICS issues
      #   run: |
      #     count=$(jq '[.queries[] | select(.severity == "HIGH" or .severity == "CRITICAL")] | length' ${{ matrix.folder }}/kics-output/results.json)
      #     echo "High/Critical findings: $count"
      #     if [ "$count" -gt 0 ]; then
      #       echo "High/Critical KICS findings â€” failing CI"
      #       exit 1
      #     fi
      
      - name: Install SonarScanner
        run: |
          wget https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/sonar-scanner-cli-5.0.1.3006-linux.zip
          unzip sonar-scanner-cli-5.0.1.3006-linux.zip
          mv sonar-scanner-5.0.1.3006-linux sonar-scanner
          echo "$PWD/sonar-scanner/bin" >> $GITHUB_PATH
          
      - name: Run SonarQube Scan
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: |
          cd ${{ matrix.folder }}
          sonar-scanner \
            -Dsonar.projectKey=htown-sp-sonarqube-${{ matrix.folder }} \
            -Dsonar.projectName=htown-sp-sonarqube-${{ matrix.folder }} \
            -Dsonar.sources=. \
            -Dsonar.host.url=${{ secrets.SONAR_HOST_URL }} \
            -Dsonar.token=$SONAR_TOKEN \
            -Dsonar.python.version=3 \
            -Dsonar.projectVersion=1.0.${{ github.run_number }} \
            -Dsonar.scm.disabled=false \
            -Dsonar.qualitygate.wait=true \
            -Dsonar.sourceEncoding=UTF-8 \
            | tee sonarqube-output.log
            
      - name: Check SonarQube Quality Gate Status
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
        run: |
          echo "Checking SonarQube Quality Gate status for $PROJECT_NAME-${{ matrix.folder }}..."
          
          # Fetch analysis task report file
          report_file="${{ matrix.folder }}/.scannerwork/report-task.txt"
          if [ ! -f "$report_file" ]; then
            echo " SonarQube report-task.txt not found. Quality Gate check skipped."
            exit 1
          fi
          
          analysisId=$(grep '^ceTaskId=' "$report_file" | cut -d'=' -f2)
          if [ -z "$analysisId" ]; then
            echo " No analysis ID found in report-task.txt. Exiting."
          exit 1
          fi
          
          echo " Waiting for analysis task to complete..."
          for i in {1..10}; do
            status=$(curl -s -u "$SONAR_TOKEN:" "$SONAR_HOST_URL/api/ce/task?id=$analysisId" | jq -r '.task.status')
            echo "Analysis status: $status"
            if [[ "$status" == "SUCCESS" ]]; then
              break
            fi
            sleep 5
          done
          
          quality_status=$(curl -s -u "$SONAR_TOKEN:" "$SONAR_HOST_URL/api/qualitygates/project_status?analysisId=$analysisId" | jq -r '.projectStatus.status')
          
          echo " Quality Gate Status: $quality_status"
          
          if [[ "$quality_status" != "OK" ]]; then
            echo " Quality Gate FAILED for $PROJECT_NAME-${{ matrix.folder }}"
          exit 1
          fi
          
          echo " Quality Gate PASSED for $PROJECT_NAME-${{ matrix.folder }}"
          
      - name: Fetch SonarQube Issues
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
        run: |
          curl -s -u "${SONAR_TOKEN}:" \
            "${SONAR_HOST_URL}/api/issues/search?componentKeys=$PROJECT_NAME-${{ matrix.folder }}" \
            -o sonarqube-results.json || echo "Failed to fetch SonarQube issues"
            
      - name: Upload SonarQube Issues to S3
        run: |
          if [ -f sonarqube-results.json ]; then
            aws s3 cp sonarqube-results.json s3://$SQ_S3_BUCKET/sonarqube/${{ matrix.folder }}/sonarqube-results.json
          else
            echo "Issues file not found, skipping upload."
          fi
          
      # Terraform Execution (After Approval)
      - name: Zip Lambda Code if applicable
        run: |
          cd ${{ matrix.folder }}
          mkdir -p build
          zip -r build/test_lambda.zip . -x "*.tf" -x "*.tfvars" -x "build/*" -x ".terraform/*" || echo "No files to zip"
          
      - name: Terraform Init
        run: terraform init
        working-directory: ${{ matrix.folder }}
        
      - name: Terraform Validate
        run: terraform validate
        working-directory: ${{ matrix.folder }}
        
      - name: Terraform Plan
        run: terraform plan -var-file="vars/dev.tfvars"
        working-directory: ${{ matrix.folder }}
        
  terraform-apply:
    name: Terraform Apply
    needs: detect-folders
    runs-on: ubuntu-latest
    environment:
      name: dev-apply  #This triggers manual approval
      url: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
    strategy:
      matrix:
        folder: ${{ fromJson(needs.detect-folders.outputs.folders) }}
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.ACCESS_KEY }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          
      - name: Terraform Init
        run: terraform init
        working-directory: ${{ matrix.folder }}
        
      - name: Terraform Apply
        run: terraform apply -auto-approve -var-file="vars/dev.tfvars"
        working-directory: ${{ matrix.folder }}
